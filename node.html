<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>최단 경로 찾기</title>
    <style>
        .canvas-container {
            overflow: hidden;
            width: 4000px;
            /* 화면에 보이는 크기 조절 */
            height: 3000px;
            /* 화면에 보이는 크기 조절 */
            transform: scale(0.3);
            /* 실제 크기에 대한 비율 조절 */
            transform-origin: 0 0;
        }

        canvas {
            border: 1px solid black;
            transform-origin: 0 0;
        }
    </style>
    <script>
        let shortestPath;

        // 그래프 생성자 함수
        function Graph() {
            this.nodes = {}; // 노드들을 저장할 객체
            this.addEdge = function (start, end, weight) { // 간선을 추가하는 메소드
                if (!this.nodes[start]) this.nodes[start] = {}; // 시작 노드가 없으면 생성
                if (!this.nodes[end]) this.nodes[end] = {}; // 끝 노드가 없으면 생성
                this.nodes[start][end] = weight; // 시작 노드에서 끝 노드로 가는 가중치 저장
                this.nodes[end][start] = weight; // 끝 노드에서 시작 노드로 가는 가중치 저장
            };
        }

        // 좌표를 주어진 각도로 회전시키는 함수
        function rotateCoordinates(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            let rotationSelect = document.getElementById("rotationSelect");
            let rotationAngle = parseInt(rotationSelect.value);
            const angle = rotationAngle; //주언진 각도 기본은 0, angle 기준으로 회전 좌표를 리턴한다.
            const radians = (angle * Math.PI) / 180;
            const cosTheta = Math.cos(radians);
            const sinTheta = Math.sin(radians);
            const newX = cosTheta * (x - centerX) - sinTheta * (y - centerY) + centerX;
            const newY = sinTheta * (x - centerX) + cosTheta * (y - centerY) + centerY;
            return [newX, newY];
        }

        // 알고리즘 함수
        function dijkstra(graph, start, end) {
            let distances = {}; // 각 노드까지의 최단 거리를 저장할 객체
            let previous = {}; // 최단 경로를 추적하기 위한 이전 노드를 저장할 객체
            let queue = []; // 방문할 노드들을 저장할 배열

            // 모든 노드의 초기 거리를 무한대로 설정
            for (let node in graph.nodes) {
                distances[node] = Infinity;
                previous[node] = null;
            }
            distances[start] = 0; // 시작 노드의 거리는 0으로 설정
            queue.push(start); // 시작 노드를 큐에 삽입

            console.log("알고리즘 시작");

            while (queue.length > 0) {
                // 현재 큐에서 가장 거리가 작은 노드 선택
                let current = queue.shift();
                console.log("현재 노드:", current);

                // 목표 노드에 도달하면 최단 경로를 찾았으므로 종료
                if (current === end) {
                    console.log("목표 노드에 도달하여 종료");
                    break;
                }

                // 현재 노드와 인접한 노드들을 확인
                for (let neighbor in graph.nodes[current]) {
                    // 현재 노드에서 인접 노드까지의 거리
                    let weight = graph.nodes[current][neighbor];
                    // 현재 노드를 거쳐서 인접 노드에 도달하는 거리
                    let distance = distances[current] + weight;

                    console.log(`현재 노드에서 ${neighbor}까지의 거리:`, distance);

                    // 더 짧은 경로를 찾은 경우 거리와 이전 노드 업데이트
                    if (distance < distances[neighbor]) {
                        distances[neighbor] = distance;
                        previous[neighbor] = current;
                        queue.push(neighbor); // 인접 노드를 큐에 삽입

                        console.log(`새로운 최단 거리 발견! ${neighbor}까지의 거리 업데이트`);
                    }
                }
            }

            // 최단 경로의 노드들을 배열로 반환
            let path = [end];
            let current = end;
            while (current !== start) {
                let prev = previous[current];
                path.unshift(prev);
                current = prev;
            }

            console.log("최단 경로:", path);

            return path.map(node => node.split(',')); // 좌표로 변환해서 반환
        }


        function readXMLFile(callback) {
            // 파일이 로컬 스토리지에 있는지 확인
            let storedGraph = localStorage.getItem("graphData");

            if (storedGraph) {
                console.log("로컬 스토리지에 있다");

                // 만약 데이터가 로컬 스토리지에 있다면, 파싱 사용
                let graph = JSON.parse(storedGraph);
                callback(graph);
            } else {
                console.log("로컬 스토리지에 없다");
                // 만약 없다면, 파일을 다운로드하고 로컬 스토리지 저장
                let url = "./node.xml";
                let xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "document";
                xhr.send();

                xhr.onload = function () {
                    let xmlDoc = xhr.responseXML;
                    let nodeList = xmlDoc.getElementsByTagName("NODE_LIST")[0];
                    let nodeInfos = nodeList.getElementsByTagName("NODE_INFO");

                    let graph = new Graph();

                    for (let nodeInfo of nodeInfos) {
                        let x1 = nodeInfo.getAttribute("x1");
                        let y1 = nodeInfo.getAttribute("y1");
                        let x2 = nodeInfo.getAttribute("x2");
                        let y2 = nodeInfo.getAttribute("y2");

                        [x1, y1] = rotateCoordinates(x1, y1);
                        [x2, y2] = rotateCoordinates(x2, y2);

                        let start = `${x1},${y1}`;
                        let end = `${x2},${y2}`;

                        let weight = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        graph.addEdge(start, end, weight);
                    }

                    // 그래프 데이터를 로컬 스토리지 저장
                    localStorage.setItem("graphData", JSON.stringify(graph));

                    callback(graph);
                };
            }
        }



        // input box에서 시작점과 종료점을 입력받아 최단 경로를 찾는 함수
        function findDrawNode() {
            // input box의 값들을 변수에 할당
            let startX = document.getElementById("startX").value;
            let startY = document.getElementById("startY").value;
            let endX = document.getElementById("endX").value;
            let endY = document.getElementById("endY").value;

            [startX, startY] = rotateCoordinates(startX, startY);
            [endX, endY] = rotateCoordinates(endX, endY);

            // 시작점과 종료점의 키값을 생성
            let start = `${startX},${startY}`;
            let end = `${endX},${endY}`;

            console.log("readXMLFile 호출 전");

            // node.xml 파일을 읽어서 그래프 객체를 생성
            readXMLFile(function (graph) {
                console.log("readXMLFile 콜백 함수 내부");

                // 알고리즘을 사용하여 최단 경로를 찾음
                shortestPath = dijkstra(graph, start, end);

                // Console에 최단 경로 출력
                // console.log(shortestPath);

                // Canvas에 그림을 그리기 위한 함수 호출
                // drawGraph(graph, shortestPath);
                drawGraph(graph);

                console.log("dijkstra 호출 후");
            });

            console.log("비동기 작업 완료 대기 중");
        }

        // Canvas에 그림을 그리기 위한 함수
        function drawGraph(graph) {
            let canvas = document.getElementById("canvas");
            let ctx = canvas.getContext("2d");

            // Canvas 초기화
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 노드 그리기
            for (let node in graph.nodes) {
                let [x, y] = node.split(',');
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = "blue";
                ctx.fill();
                ctx.stroke();
            }

            // 시작점 그리기 (파란색 동그라미)
            let startX = document.getElementById("startX").value;
            let startY = document.getElementById("startY").value;
            [startX, startY] = rotateCoordinates(startX, startY);

            ctx.beginPath();
            ctx.arc(startX, startY, 10, 0, 3 * Math.PI);
            ctx.fillStyle = "pink";
            ctx.fill();
            ctx.stroke();

            // 종료점 그리기 (노란색 사각형)
            let endX = document.getElementById("endX").value;
            let endY = document.getElementById("endY").value;
            [endX, endY] = rotateCoordinates(endX, endY);
            ctx.beginPath();
            ctx.rect(endX - 5, endY - 5, 20, 20);
            ctx.fillStyle = "yellow";
            ctx.fill();
            ctx.stroke();

            // 간선 그리기
            for (let edge of Object.keys(graph.nodes)) {
                for (let neighbor of Object.keys(graph.nodes[edge])) {
                    let [x1, y1] = edge.split(',');
                    let [x2, y2] = neighbor.split(',');
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 2; // 굵기 설정
                    ctx.stroke();
                }
            }

            // drawFindLoad(shortestPath);

            // // 최단 경로 그리기
            // ctx.beginPath();
            // ctx.moveTo(shortestPath[0][0], shortestPath[0][1]);
            // for (let i = 1; i < shortestPath.length; i++) {
            //     let [x, y] = shortestPath[i];
            //     ctx.lineTo(x, y);
            // }
            // ctx.strokeStyle = "red";
            // ctx.lineWidth = 3; // 굵기 설정
            // ctx.stroke();
        }

        function findDrawPath() {
            drawFindLoad(shortestPath);
        }

        function drawFindLoad(shortestPath) {
            let canvas = document.getElementById("canvas");
            let ctx = canvas.getContext("2d");
            // 최단 경로 그리기
            ctx.beginPath();
            ctx.moveTo(shortestPath[0][0], shortestPath[0][1]);
            for (let i = 1; i < shortestPath.length; i++) {
                let [x, y] = shortestPath[i];
                ctx.lineTo(x, y);
            }
            ctx.strokeStyle = "red";
            ctx.lineWidth = 3; // 굵기 설정
            ctx.stroke();
        }

        // Canvas 초기화를 위한 함수
        function clearCanvas() {
            let canvas = document.getElementById("canvas");
            let ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // 최단 경로 삭제를 위한 함수
        function clearShortestPath() {
            // Canvas 초기화
            clearCanvas();

            // 다시 노드 간의 연결된 선을 그리기
            readXMLFile(function (graph) {
                drawGraph(graph, []);
            });
        }

        // 마우스 클릭 이벤트 핸들러
        function handleMouseClick(event) {
            let mouseX = event.clientX;
            let mouseY = event.clientY;

            readXMLFile(function (graph) {
                let minDistance = Infinity;
                let nearestNode = null;

                for (let node in graph.nodes) {
                    let [nodeX, nodeY] = node.split(',');
                    let distance = Math.sqrt(Math.pow(mouseX - nodeX, 2) + Math.pow(mouseY - nodeY, 2));

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestNode = node;
                    }
                }

                console.log(`가장 가까운 노드: ${nearestNode}`);

                // 가장 가까운 노드에 원 그리기
                let [nearestX, nearestY] = nearestNode.split(',');
                let canvas = document.getElementById("canvas");
                let ctx = canvas.getContext("2d");
                ctx.beginPath();
                ctx.arc(nearestX, nearestY, 15, 0, 2 * Math.PI); // 수정된 부분: 반지름 5로 변경
                ctx.fillStyle = "gray"; // 수정된 부분: 빨간색으로 설정
                ctx.fill();
                ctx.stroke();

                // Alert로 x, y 좌표 출력
                alert(`클릭한 노드의 좌표: x=${nearestX}, y=${nearestY}`);
            });
        }


        document.addEventListener("DOMContentLoaded", function () {
            // rotationSelect 값이 변경될 때 호출되는 함수
            function handleRotationChange() {
                // 로컬 스토리지에서 "graphData" 삭제
                localStorage.removeItem("graphData");

                console.log("로컬 스토리지에서 데이터 삭제");
            }

            // rotationSelect 요소에 이벤트 핸들러 등록
            let rotationSelect = document.getElementById("rotationSelect");
            if (rotationSelect) {
                rotationSelect.addEventListener("change", handleRotationChange);
            }
        });

    </script>
</head>

<body>
    <h1>최단 경로 찾기</h1>
    <p>시작점과 종료점의 좌표를 입력하세요.</p>
    시작점 x: <input type="number" id="startX" value="919"> <!-- 입력하기 귀찮아서 고정 -->
    시작점 y: <input type="number" id="startY" value="739"><br><!-- 입력하기 귀찮아서 고정 -->
    종료점 x: <input type="number" id="endX" value="2067"><!-- 입력하기 귀찮아서 고정 -->
    종료점 y: <input type="number" id="endY" value="1322"><br><!-- 입력하기 귀찮아서 고정 -->
    <button onclick="findDrawNode()">경로 그리기</button>
    <button onclick="findDrawPath()">최단 경로 찾기</button>
    <button onclick="clearShortestPath()">최단 경로 삭제</button>
    <select id="rotationSelect">
        <option value="0">0도</option>
        <option value="10">10도</option>
        <option value="20">20도</option>
        <option value="30">30도</option>
        <option value="40">40도</option>
        <option value="50">50도</option>
        <option value="60">60도</option>
        <option value="70">70도</option>
        <option value="80">80도</option>
        <option value="90">90도</option>
        <option value="100">100도</option>
        <option value="110">110도</option>
        <option value="120">120도</option>
        <option value="130">130도</option>
        <option value="140">140도</option>
        <option value="150">150도</option>
        <option value="160">160도</option>
        <option value="170">170도</option>
        <option value="180">180도</option>
        <option value="270">270도</option>
    </select>
    <!-- 첫 번째 캔버스 -->
    <div class="canvas-container">
        <canvas id="canvas" width="4000" height="3000" onmouseup="handleMouseUp(event)"
            onclick="handleMouseClick(event)"></canvas>
    </div>

</body>

</html>